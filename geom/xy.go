package geom

import (
	"fmt"
	"math"

	"github.com/peterstace/simplefeatures/rtree"
)

// XY represents a pair of X and Y coordinates. This can either represent a
// location on the XY plane, or a 2D vector in the real vector space.
type XY struct {
	X, Y float64
}

// validate checks if the XY value contains NaN, -inf, or +inf.
func (w XY) validate() error {
	if math.IsNaN(w.X) || math.IsInf(w.X, 0) {
		return fmt.Errorf("invalid X value: %v", w.X)
	}
	if math.IsNaN(w.Y) || math.IsInf(w.Y, 0) {
		return fmt.Errorf("invalid Y value: %v", w.Y)
	}
	return nil
}

// AsPoint is a convenience function to convert this XY value into a Point
// geometry.
func (w XY) AsPoint(opts ...ConstructorOption) (Point, error) {
	coords := Coordinates{XY: w, Type: DimXY}
	return NewPoint(coords, opts...)
}

// asUncheckedPoint is a convenience function to convert this XY value into a
// Point. The Point is constructed without checking any validations. It may be
// used internally when the caller is sure that the XY value doesn't come
// directly from outside of the library without first being validated.
func (w XY) asUncheckedPoint() Point {
	coords := Coordinates{XY: w, Type: DimXY}
	return newUncheckedPoint(coords)
}

// uncheckedEnvelope is a convenience function to convert this XY value into
// a (degenerate) envelope that represents a single XY location (i.e. a zero
// area envelope). It may be used internally when the caller is sure that the
// XY value doesn't come directly from outline the library without first being
// validated.
func (w XY) uncheckedEnvelope() Envelope {
	return newUncheckedEnvelope(w, w)
}

// Sub returns the result of subtracting the other XY from this XY (in the same
// manner as vector subtraction).
func (w XY) Sub(o XY) XY {
	return XY{
		w.X - o.X,
		w.Y - o.Y,
	}
}

// Add returns the result of adding this XY to another XY (in the same manner
// as vector addition).
func (w XY) Add(o XY) XY {
	return XY{
		w.X + o.X,
		w.Y + o.Y,
	}
}

// Scale returns the XY where the X and Y have been scaled by s.
func (w XY) Scale(s float64) XY {
	return XY{
		w.X * s,
		w.Y * s,
	}
}

// Cross returns the 2D cross product of this and another XY. This is defined
// as the 'z' coordinate of the regular 3D cross product.
func (w XY) Cross(o XY) float64 {
	// Avoid fused multiply-add by explicitly converting intermediate products
	// to float64. This ensures that the cross product is *exactly* zero for
	// all linearly dependent inputs.
	return float64(w.X*o.Y) - float64(w.Y*o.X)
}

// Midpoint returns the midpoint of this and another XY.
func (w XY) Midpoint(o XY) XY {
	return w.Add(o).Scale(0.5)
}

// Dot returns the dot product of this and another XY.
func (w XY) Dot(o XY) float64 {
	return w.X*o.X + w.Y*o.Y
}

// Unit treats the XY as a vector, and scales it to have unit length.
func (w XY) Unit() XY {
	return w.Scale(1 / w.Length())
}

// Length treats XY as a vector, and returns its length.
func (w XY) Length() float64 {
	return math.Sqrt(w.lengthSq())
}

// lengthSq treats XY as a vector, and returns its squared length.
func (w XY) lengthSq() float64 {
	return w.Dot(w)
}

// Less gives an ordering on XYs. If two XYs have different X values, then the
// one with the lower X value is ordered before the one with the higher X
// value. If the X values are then same, then the Y values are used (the lower
// Y value comes first).
func (w XY) Less(o XY) bool {
	if w.X != o.X {
		return w.X < o.X
	}
	return w.Y < o.Y
}

func (w XY) distanceTo(o XY) float64 {
	return math.Sqrt(w.distanceSquaredTo(o))
}

func (w XY) distanceSquaredTo(o XY) float64 {
	delta := o.Sub(w)
	return delta.Dot(delta)
}

func (w XY) box() rtree.Box {
	return rtree.Box{
		MinX: w.X,
		MinY: w.Y,
		MaxX: w.X,
		MaxY: w.Y,
	}
}
